<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
      Helvetica, Arial, sans-serif;
    margin: 16px;
    font-size: 14px;
    background: linear-gradient(135deg, #d0eaea 0%, #f6f6ec 100%);
    min-height: 100vh;
  }

  h1 {
    font-size: 24px;
    text-align: center;
    margin-bottom: 20px;
  }

  .plugin-description {
    font-size: 13px;
    color: #6c757d;
    text-align: center;
    line-height: 1.4;
    margin-bottom: 20px;
    padding: 0 8px;
  }

  #results {
    margin-top: 8px;
  }

  #results:has(#resultsTable) {
    background-color: white;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  #resultsTable {
    width: 100%;
    border-collapse: collapse;
    margin-top: 12px;
    background-color: white;
  }

  #resultsTable th,
  #resultsTable td {
    border: 1px solid #e5e5e5;
    padding: 8px;
    text-align: left;
    vertical-align: top;
    background-color: white;
  }

  #resultsTable th {
    background-color: #f5f5f5;
    font-weight: 600;
  }

  .word-cell {
    color: #d92d20;
    font-weight: 500;
    cursor: pointer;
    text-decoration: underline;
    transition: all 0.2s ease;
    position: relative;
    background-color: white;
  }

  .word-cell:hover {
    background-color: #f0f0f0;
  }

  /* Edit mode styles */
  .word-cell.editing {
    background-color: #fff3cd;
    border: 2px solid #ffc107;
    border-radius: 4px;
    padding: 6px;
    text-decoration: none;
  }

  .word-edit-input {
    background: transparent;
    border: none;
    outline: none;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    color: inherit;
    width: 100%;
    min-width: 80px;
  }

  .edit-controls {
    margin-top: 8px;
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .save-btn {
    background-color: #28a745;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .save-btn:hover {
    background-color: #218838;
  }

  .cancel-btn {
    background-color: #6c757d;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .cancel-btn:hover {
    background-color: #5a6268;
  }

  .edit-hint {
    font-size: 11px;
    color: #6c757d;
    font-style: italic;
  }

  .suggestion-btn {
    background-color: transparent;
    border: none;
    color: #007bff;
    padding: 2px 4px;
    margin-right: 4px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    text-decoration: underline;
  }

  .suggestion-btn:hover {
    background-color: #e9ecef;
  }

  #spellCheckButton {
    background-color: #2c9acf;
    color: white;
    border: none;
    padding: 12px 0px;
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    width: 100%;
    transition: background-color 0.2s ease;
    margin-bottom: 16px;
  }

  #spellCheckButton:hover {
    background-color: #2588b8;
  }
</style>

<h1>Check Spelling</h1>
<p class="plugin-description">
  Automatically scan your Figma design for misspelled words. Click on any
  misspelled word to highlight all instances, or double-click to edit and
  replace across your entire document.
</p>
<button id="spellCheckButton">Check Spellings</button>
<div id="summary"></div>
<div id="results"></div>

<script src="https://cdn.jsdelivr.net/npm/@ocordes/typo-js@1.1.0-2/typo.min.js"></script>

<script>
  // Ensure all code inside is executed after the window is fully loaded
  window.onload = () => {
    if (typeof Typo === "undefined") {
      document.getElementById("results").innerHTML =
        '<strong style="color:red;">Error: The typo.js library failed to load.</strong>';
      return;
    }

    const spellCheckButton = document.getElementById("spellCheckButton");
    const resultsDiv = document.getElementById("results");
    const summaryDiv = document.getElementById("summary");

    // Variables to handle click timing
    let clickTimer = null;
    let currentlyEditing = null;

    // Sends a message to the code.ts (parent window) to initiate spell checking
    spellCheckButton.onclick = () => {
      resultsDiv.innerHTML = "Scanning page for text...";
      summaryDiv.innerHTML = "";
      parent.postMessage({ pluginMessage: { type: "spell-check" } }, "*");
    };

    // It receives an Array of text data from code.ts (parent window) and processes it
    window.onmessage = async (event) => {
      const message = event.data.pluginMessage;

      if (message.type === "text-to-check") {
        resultsDiv.innerHTML = "Loading dictionary...";
        const allTextData = message.payload;

        // It fetches the dictionary files (.aff and .dic) from the web
        try {
          const affUrl =
            "https://cdn.jsdelivr.net/npm/typo-js@1.2.5/dictionaries/en_US/en_US.aff";
          const dicUrl =
            "https://cdn.jsdelivr.net/npm/typo-js@1.2.5/dictionaries/en_US/en_US.dic";
          const [affResponse, dicResponse] = await Promise.all([
            fetch(affUrl),
            fetch(dicUrl),
          ]);
          if (!affResponse.ok || !dicResponse.ok)
            throw new Error(`Failed to fetch dictionary files.`);
          const affText = await affResponse.text();
          const dicText = await dicResponse.text();

          resultsDiv.innerHTML = "Checking spelling...";
          const dictionary = new Typo("en_US", affText, dicText);

          const ignoreList = [
            "prathyaksh",
            "begumpet",
            "secundrabad",
            "figma",
            "telapur",
            "medchal",
            "ghatkesar",
            "sanathnagar",
            "ferozguda",
            "suchitra",
            "bhudevi",
            "ammuguda",
            "neredmet",
          ];

          let errors = {};
          allTextData.forEach((nodeData) => {
            const words = nodeData.text.match(/[a-zA-Z']+/g) || [];
            words.forEach((word) => {
              const lowerCaseWord = word.toLowerCase();

              if (word.length <= 2) return;
              if (word === word.toUpperCase() && word.length > 1) return;
              if (ignoreList.includes(lowerCaseWord)) return;

              if (word.length > 0 && !dictionary.check(word)) {
                if (!errors[word]) {
                  errors[word] = {
                    suggestions: dictionary.suggest(word),
                    nodes: new Set(),
                  };
                }
                errors[word].nodes.add(nodeData.id);
              }
            });
          });

          const uniqueErrorCount = Object.keys(errors).length;
          if (uniqueErrorCount > 0) {
            summaryDiv.innerHTML = `<strong>Found ${uniqueErrorCount} unique misspelled words.</strong>`;

            let tableHTML = `<table id="resultsTable"><thead><tr><th>S.No</th><th>Misspelled Word</th><th>Suggestions</th></tr></thead><tbody>`;
            let serialNumber = 1;
            for (const [word, data] of Object.entries(errors)) {
              tableHTML += `<tr id="row-${word}">
                              <td>${serialNumber++}</td>
                              <td class="word-cell" 
                                  title="Single click: highlight | Double click: edit" 
                                  data-word="${word}"
                                  data-node-ids='${JSON.stringify(
                                    Array.from(data.nodes)
                                  )}'>
                                <span class="word-text">${word}</span>
                              </td>
                              <td>`;
              data.suggestions.slice(0, 5).forEach((suggestion) => {
                tableHTML += `<button class="suggestion-btn" data-old-word="${word}" data-new-word="${suggestion}" data-node-ids='${JSON.stringify(
                  Array.from(data.nodes)
                )}'>${suggestion}</button> `;
              });
              tableHTML += `</td></tr>`;
            }
            tableHTML += `</tbody></table>`;
            resultsDiv.innerHTML = tableHTML;

            parent.postMessage(
              {
                pluginMessage: {
                  type: "resize-window",
                  width: 750,
                  height: 850,
                },
              },
              "*"
            );
          } else {
            summaryDiv.innerHTML = "";
            resultsDiv.innerHTML = "No spelling errors found!";
            parent.postMessage(
              { pluginMessage: { type: "clear-highlights" } },
              "*"
            );
          }
        } catch (error) {
          console.error("Error during spell check:", error);
          resultsDiv.innerHTML = `<strong style="color:red;">Error: Could not process text.</strong>`;
        }
      } else if (message.type === "word-replaced") {
        spellCheckButton.click();
      } else if (message.type === "re-check-document") {
        spellCheckButton.click();
      }
    };

    // Function to handle single click (highlight)
    function handleSingleClick(target) {
      const nodeIds = JSON.parse(target.dataset.nodeIds);
      parent.postMessage(
        {
          pluginMessage: { type: "highlight-and-navigate", payload: nodeIds },
        },
        "*"
      );
    }

    // Function to handle double click (edit mode)
    function handleDoubleClick(target) {
      // Exit any existing edit mode
      if (currentlyEditing) {
        exitEditMode(currentlyEditing, false);
      }

      const word = target.dataset.word;
      const nodeIds = target.dataset.nodeIds;

      // Enter edit mode
      enterEditMode(target, word, nodeIds);
    }

    // Function to enter edit mode
    function enterEditMode(cell, word, nodeIds) {
      currentlyEditing = cell;
      cell.classList.add("editing");

      const wordSpan = cell.querySelector(".word-text");
      const originalHTML = cell.innerHTML;

      cell.innerHTML = `
        <input type="text" class="word-edit-input" value="${word}" />
        <div class="edit-controls">
          <button class="save-btn">Save</button>
          <button class="cancel-btn">Cancel</button>
          <span class="edit-hint">This will replace all instances</span>
        </div>
      `;

      const input = cell.querySelector(".word-edit-input");
      const saveBtn = cell.querySelector(".save-btn");
      const cancelBtn = cell.querySelector(".cancel-btn");

      // Focus and select the input
      input.focus();
      input.select();

      // Handle save
      saveBtn.onclick = (e) => {
        e.stopPropagation();
        const newWord = input.value.trim();
        if (newWord && newWord !== word) {
          // Send replace message to code.ts
          parent.postMessage(
            {
              pluginMessage: {
                type: "replace-word",
                payload: {
                  nodeIds: JSON.parse(nodeIds),
                  oldWord: word,
                  newWord: newWord,
                },
              },
            },
            "*"
          );
        }
        exitEditMode(cell, true);
      };

      // Handle cancel
      cancelBtn.onclick = (e) => {
        e.stopPropagation();
        exitEditMode(cell, false);
      };

      // Handle Enter key to save
      input.onkeydown = (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          saveBtn.click();
        } else if (e.key === "Escape") {
          e.preventDefault();
          cancelBtn.click();
        }
      };
    }

    // Function to exit edit mode
    function exitEditMode(cell, saved) {
      if (!cell) return;

      const word = cell.dataset.word;
      cell.classList.remove("editing");
      cell.innerHTML = `<span class="word-text">${word}</span>`;
      currentlyEditing = null;

      if (saved) {
        // The spell check will be re-triggered by the word-replaced message
      }
    }

    // Event listener with single/double click handling
    resultsDiv.addEventListener("click", (event) => {
      const target = event.target;

      // Handle suggestion button clicks (unchanged)
      if (target.classList.contains("suggestion-btn")) {
        const nodeIds = JSON.parse(target.dataset.nodeIds);
        const oldWord = target.dataset.oldWord;
        const newWord = target.dataset.newWord;
        parent.postMessage(
          {
            pluginMessage: {
              type: "replace-word",
              payload: { nodeIds, oldWord, newWord },
            },
          },
          "*"
        );
        return;
      }

      // Handle word cell clicks (single vs double click)
      if (
        target.classList.contains("word-cell") ||
        target.closest(".word-cell")
      ) {
        const cell = target.classList.contains("word-cell")
          ? target
          : target.closest(".word-cell");

        // Ignore clicks if we're in edit mode
        if (cell.classList.contains("editing")) {
          return;
        }

        event.preventDefault();

        // Clear any existing timer
        if (clickTimer) {
          clearTimeout(clickTimer);
          clickTimer = null;
          // This is a double click
          handleDoubleClick(cell);
        } else {
          // Set timer for single click
          clickTimer = setTimeout(() => {
            clickTimer = null;
            handleSingleClick(cell);
          }, 300); // 300ms delay to detect double click
        }
      }
    });

    // Prevent double-click text selection
    resultsDiv.addEventListener("selectstart", (event) => {
      if (
        event.target.classList.contains("word-cell") ||
        event.target.closest(".word-cell")
      ) {
        event.preventDefault();
      }
    });
  };
</script>

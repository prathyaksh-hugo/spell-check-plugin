<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segma UI", Roboto,
      Helvetica, Arial, sans-serif;
    margin: 16px;
    font-size: 14px;
    background: linear-gradient(135deg, #d0eaea 0%, #f6f6ec 100%);
    min-height: 100vh;
  }

  h1 {
    font-size: 24px;
    text-align: center;
    margin-bottom: 20px;
  }

  .plugin-description {
    font-size: 13px;
    color: #6c757d;
    text-align: center;
    line-height: 1.4;
    margin-bottom: 20px;
    padding: 0 8px;
  }

  #results {
    margin-top: 8px;
  }

  #results:has(#resultsTable) {
    background-color: white;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  #resultsTable {
    width: 100%;
    border-collapse: collapse;
    margin-top: 12px;
    background-color: white;
  }

  #resultsTable th,
  #resultsTable td {
    border: 1px solid #e5e5e5;
    padding: 8px;
    text-align: left;
    vertical-align: top;
    background-color: white;
  }

  #resultsTable th {
    background-color: #f5f5f5;
    font-weight: 600;
  }

  .word-cell {
    color: #d92d20;
    font-weight: 500;
    cursor: pointer;
    
    transition: all 0.2s ease;
    position: relative;
    background-color: white;
  }

  .word-cell:hover {
    background-color: #fef2f2;
    color: #b91c1c;
  }

  .word-container {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .word-main {
    flex: 1;
    min-width: 0;
  }

  .navigation-controls {
    display: flex;
    align-items: center;
    gap: 4px;
    flex-shrink: 0;
  }

  .nav-btn {
    background-color: #f3f4f6;
    border: 1px solid #d1d5db;
    color: #374151;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 35px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none !important;
  }

  .nav-btn:hover:not(:disabled) {
    background-color: #e5e7eb;
    border-color: #9ca3af;
  }

  .nav-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .navigation-info {
    font-size: 10px;
    color: #059669;
    font-weight: 500;
    background-color: #ecfdf5;
    padding: 2px 6px;
    border-radius: 12px;
    border: 1px solid #d1fae5;
    text-decoration: none !important;
  }

  /* Edit mode styles */
  .word-cell.editing {
    background-color: #fff3cd;
    border: 2px solid #ffc107;
    border-radius: 4px;
    padding: 6px;
    text-decoration: none;
  }

  .word-edit-input {
    background: transparent;
    border: none;
    outline: none;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    color: inherit;
    width: 100%;
    min-width: 80px;
  }

  .edit-controls {
    margin-top: 8px;
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .save-btn {
    background-color: #28a745;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .save-btn:hover {
    background-color: #218838;
  }

  .cancel-btn {
    background-color: #6c757d;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .cancel-btn:hover {
    background-color: #5a6268;
  }

  .edit-hint {
    font-size: 11px;
    color: #6c757d;
    font-style: italic;
  }

  .suggestion-btn {
    background-color: transparent;
    border: none;
    color: #007bff;
    padding: 2px 4px;
    margin-right: 4px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    text-decoration: underline;
  }

  .suggestion-btn:hover {
    background-color: #e9ecef;
  }

  #spellCheckButton {
    background-color: #2c9acf;
    color: white;
    border: none;
    padding: 12px 0px;
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    width: 100%;
    transition: background-color 0.2s ease;
    margin-bottom: 16px;
  }

  #spellCheckButton:hover {
    background-color: #2588b8;
  }

  #spellCheckButton:disabled {
    background-color: #94a3b8;
    cursor: not-allowed;
  }

  .loading {
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }

  .spinner {
    width: 16px;
    height: 16px;
    border: 2px solid #ffffff50;
    border-top: 2px solid #ffffff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>

<h1>Check Spelling</h1>
<p class="plugin-description">
  Automatically scan your Figma design for misspelled words. Click on any
  misspelled word to navigate, use prev/next buttons for multiple instances, or double-click to edit and
  replace across your entire document.
</p>
<button id="spellCheckButton">Check Spellings</button>
<div id="summary"></div>
<div id="results"></div>

<script src="https://cdn.jsdelivr.net/npm/@ocordes/typo-js@1.1.0-2/typo.min.js"></script>

<script>
  // Cached dictionary for performance
  let cachedDictionary = null;
  let isLoading = false;
  let navigationStates = {};
  let currentlyEditing = null;
  let clickTimer = null;
  let lastCheckTime = 0;

  // Ensure all code inside is executed after the window is fully loaded
  window.onload = () => {
    if (typeof Typo === "undefined") {
      document.getElementById("results").innerHTML =
        '<strong style="color:red;">Error: The typo.js library failed to load.</strong>';
      return;
    }

    const spellCheckButton = document.getElementById("spellCheckButton");
    const resultsDiv = document.getElementById("results");
    const summaryDiv = document.getElementById("summary");

    // Preload dictionary for instant performance
    preloadDictionary();

    // Sends a message to the code.ts (parent window) to initiate spell checking
    spellCheckButton.onclick = () => {
      if (isLoading) return;
      
      isLoading = true;
      spellCheckButton.disabled = true;
      spellCheckButton.innerHTML = '<div class="loading"><div class="spinner"></div>Scanning...</div>';
      
      resultsDiv.innerHTML = "Scanning page for text...";
      summaryDiv.innerHTML = "";
      
      parent.postMessage({ pluginMessage: { type: "spell-check" } }, "*");
    };

    // Preload dictionary for instant performance
    async function preloadDictionary() {
      if (cachedDictionary) return cachedDictionary;
      
      try {
        const affUrl = "https://cdn.jsdelivr.net/npm/typo-js@1.2.5/dictionaries/en_US/en_US.aff";
        const dicUrl = "https://cdn.jsdelivr.net/npm/typo-js@1.2.5/dictionaries/en_US/en_US.dic";
        
        const [affResponse, dicResponse] = await Promise.all([
          fetch(affUrl),
          fetch(dicUrl),
        ]);
        
        if (!affResponse.ok || !dicResponse.ok) {
          throw new Error(`Failed to fetch dictionary files.`);
        }
        
        const affText = await affResponse.text();
        const dicText = await dicResponse.text();
        cachedDictionary = new Typo("en_US", affText, dicText);
        
        return cachedDictionary;
      } catch (error) {
        console.error("Error preloading dictionary:", error);
        return null;
      }
    }

    // Optimized spell check processing
    async function processSpellCheck(allTextData) {
      try {
        // Use cached dictionary or load it
        const dictionary = cachedDictionary || await preloadDictionary();
        if (!dictionary) throw new Error("Could not load dictionary");

        const ignoreList = [
          "prathyaksh", "begumpet", "secundrabad", "figma", "telapur",
          "medchal", "ghatkesar", "sanathnagar", "ferozguda", "suchitra",
          "bhudevi", "ammuguda", "neredmet",
        ];

        let errors = {};
        
        // Optimized text processing
        allTextData.forEach((nodeData) => {
          const words = nodeData.text.match(/[a-zA-Z']+/g) || [];
          words.forEach((word) => {
            const lowerCaseWord = word.toLowerCase();

            if (word.length <= 2) return;
            if (word === word.toUpperCase() && word.length > 1) return;
            if (ignoreList.includes(lowerCaseWord)) return;

            if (word.length > 0 && !dictionary.check(word)) {
              if (!errors[word]) {
                errors[word] = {
                  suggestions: dictionary.suggest(word).slice(0, 5), // Limit suggestions
                  nodes: new Set(),
                };
              }
              errors[word].nodes.add(nodeData.id);
            }
          });
        });

        displayResults(errors);
        
      } catch (error) {
        console.error("Error during spell check:", error);
        resultsDiv.innerHTML = `<strong style="color:red;">Error: Could not process text.</strong>`;
      } finally {
        isLoading = false;
        spellCheckButton.disabled = false;
        spellCheckButton.innerHTML = 'Check Spellings';
      }
    }

    // Display results with navigation and editing features
    function displayResults(errors) {
      const uniqueErrorCount = Object.keys(errors).length;
      
      if (uniqueErrorCount > 0) {
        summaryDiv.innerHTML = `<strong>Found ${uniqueErrorCount} unique misspelled words.</strong>`;

        let tableHTML = `<table id="resultsTable"><thead><tr><th>S.No</th><th>Misspelled Word</th><th>Suggestions</th></tr></thead><tbody>`;
        let serialNumber = 1;
        
        for (const [word, data] of Object.entries(errors)) {
          const nodeIds = Array.from(data.nodes);
          const instanceCount = nodeIds.length;
          
          tableHTML += `<tr id="row-${word}">
                        <td>${serialNumber++}</td>
                        <td class="word-cell" 
                            data-word="${word}"
                            data-instance-count="${instanceCount}"
                            data-node-ids='${JSON.stringify(nodeIds)}'>
                          <div class="word-container">
                            <div class="word-main">
                              <span class="word-text" 
                                    title="Click to navigate | Double click: edit"
                                    style="cursor: pointer;">${word}</span>
                            </div>
                            ${instanceCount > 1 ? `
                            <div class="navigation-controls">
                              <button class="nav-btn" data-action="prev" data-word="${word}" title="Previous instance">‹</button>
                              <span class="navigation-info" id="nav-${word}">1/${instanceCount}</span>
                              <button class="nav-btn" data-action="next" data-word="${word}" title="Next instance">›</button>
                            </div>
                            ` : ''}
                          </div>
                        </td>
                        <td>`;
          
          data.suggestions.forEach((suggestion) => {
            tableHTML += `<button class="suggestion-btn" data-old-word="${word}" data-new-word="${suggestion}" data-node-ids='${JSON.stringify(nodeIds)}'>${suggestion}</button> `;
          });
          
          tableHTML += `</td></tr>`;
        }
        
        tableHTML += `</tbody></table>`;
        resultsDiv.innerHTML = tableHTML;

        parent.postMessage({
          pluginMessage: {
            type: "resize-window",
            width: 800,
            height: Math.min(850, 300 + uniqueErrorCount * 45),
          },
        }, "*");
      } else {
        summaryDiv.innerHTML = "";
        resultsDiv.innerHTML = "No spelling errors found! ✓";
        parent.postMessage({ pluginMessage: { type: "clear-navigation" } }, "*");
      }
    }

    // Message handling with navigation support
    window.onmessage = async (event) => {
      const message = event.data.pluginMessage;

      if (message.type === "text-to-check") {
        const currentTime = Date.now();
        // Prevent duplicate calls within 500ms
        if (currentTime - lastCheckTime < 500) return;
        lastCheckTime = currentTime;

        await processSpellCheck(message.payload);
        
      } else if (message.type === "word-replaced") {
        // Clear navigation state for replaced word
        delete navigationStates[message.word];
        // Automatically recheck
        setTimeout(() => spellCheckButton.click(), 100);
        
      } else if (message.type === "navigation-update") {
        // Update navigation display
        const { word, currentIndex, totalInstances } = message.payload;
        const navElement = document.getElementById(`nav-${word}`);
        if (navElement && totalInstances > 1) {
          navElement.textContent = `${currentIndex}/${totalInstances}`;
        }
        
      } else if (message.type === "re-check-document") {
        // Debounce re-checks
        setTimeout(() => {
          if (!isLoading) {
            spellCheckButton.click();
          }
        }, 1000);
      }
    };

    // Navigation click handlers
    function handleNavigationClick(target) {
      const word = target.dataset.word;
      const nodeIds = JSON.parse(target.dataset.nodeIds);
      
      parent.postMessage({
        pluginMessage: { 
          type: "navigate-to-word", 
          payload: { word, nodeIds } 
        },
      }, "*");
    }

    function handlePrevNext(action, word) {
      parent.postMessage({
        pluginMessage: { 
          type: action === 'prev' ? "navigate-prev" : "navigate-next", 
          payload: { word } 
        },
      }, "*");
    }

    // Edit mode functions
    function handleDoubleClick(target) {
      if (currentlyEditing) {
        exitEditMode(currentlyEditing, false);
      }

      // Find the closest word cell
      const wordCell = target.closest('.word-cell');
      if (!wordCell) return;

      const word = wordCell.dataset.word;
      const nodeIds = wordCell.dataset.nodeIds;
      enterEditMode(wordCell, word, nodeIds);
    }

    function enterEditMode(cell, word, nodeIds) {
      currentlyEditing = cell;
      cell.classList.add("editing");

      cell.innerHTML = `
        <input type="text" class="word-edit-input" value="${word}" />
        <div class="edit-controls">
          <button class="save-btn">Save</button>
          <button class="cancel-btn">Cancel</button>
          <span class="edit-hint">This will replace all instances</span>
        </div>
      `;

      const input = cell.querySelector(".word-edit-input");
      const saveBtn = cell.querySelector(".save-btn");
      const cancelBtn = cell.querySelector(".cancel-btn");

      input.focus();
      input.select();

      saveBtn.onclick = (e) => {
        e.stopPropagation();
        const newWord = input.value.trim();
        if (newWord && newWord !== word) {
          parent.postMessage({
            pluginMessage: {
              type: "replace-word",
              payload: {
                nodeIds: JSON.parse(nodeIds),
                oldWord: word,
                newWord: newWord,
              },
            },
          }, "*");
        }
        exitEditMode(cell, true);
      };

      cancelBtn.onclick = (e) => {
        e.stopPropagation();
        exitEditMode(cell, false);
      };

      input.onkeydown = (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          saveBtn.click();
        } else if (e.key === "Escape") {
          e.preventDefault();
          cancelBtn.click();
        }
      };
    }

    function exitEditMode(cell, saved) {
      if (!cell) return;

      const word = cell.dataset.word;
      const instanceCount = parseInt(cell.dataset.instanceCount);
      
      cell.classList.remove("editing");
      
      // Rebuild the cell content 
      let cellHTML = `
        <div class="word-container">
          <div class="word-main">
            <span class="word-text" 
                  title="Click to navigate | Double click: edit"
                  style="cursor: pointer;">${word}</span>
          </div>
          ${instanceCount > 1 ? `
          <div class="navigation-controls">
            <button class="nav-btn" data-action="prev" data-word="${word}" title="Previous instance">‹</button>
            <span class="navigation-info" id="nav-${word}">1/${instanceCount}</span>
            <button class="nav-btn" data-action="next" data-word="${word}" title="Next instance">›</button>
          </div>
          ` : ''}
        </div>
      `;
      
      cell.innerHTML = cellHTML;
      currentlyEditing = null;
    }

    // Enhanced event listener
    resultsDiv.addEventListener("click", (event) => {
      const target = event.target;

      // Handle suggestion button clicks
      if (target.classList.contains("suggestion-btn")) {
        const nodeIds = JSON.parse(target.dataset.nodeIds);
        const oldWord = target.dataset.oldWord;
        const newWord = target.dataset.newWord;
        parent.postMessage({
          pluginMessage: {
            type: "replace-word",
            payload: { nodeIds, oldWord, newWord },
          },
        }, "*");
        return;
      }

      // Handle prev/next navigation buttons
      if (target.classList.contains("nav-btn")) {
        const action = target.dataset.action;
        const word = target.dataset.word;
        handlePrevNext(action, word);
        return;
      }

      // Handle word text clicks
      if (target.classList.contains("word-text")) {
        const cell = target.closest('.word-cell');
        if (!cell || cell.classList.contains("editing")) return;

        event.preventDefault();

        if (clickTimer) {
          clearTimeout(clickTimer);
          clickTimer = null;
          handleDoubleClick(target);
        } else {
          clickTimer = setTimeout(() => {
            clickTimer = null;
            handleNavigationClick(cell);
          }, 300);
        }
      }
    });

    // Prevent text selection on double-click
    resultsDiv.addEventListener("selectstart", (event) => {
      if (event.target.classList.contains("word-text") || event.target.closest(".word-cell")) {
        event.preventDefault();
      }
    });
  };
</script>
